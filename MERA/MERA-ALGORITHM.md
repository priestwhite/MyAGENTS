# MERA 原始演算法

> **來源**：原始設計筆記  
> **狀態**：歷史參考文件

---

## 演算法定義

```
# MERA: MCP-Enhanced Reasoning Algorithm
# 輸入: User Query (Q)
# 輸出: Response (R) + Memory Update (if needed)

步驟1: 記憶檢索 (Memory Retrieval)
    - 查詢MCP: 用Q的關鍵詞/向量嵌入搜尋，提取Top-3相關記憶片段 (M1, M2, M3)。
    - 如果無相關記憶: 設定M = "新任務，無歷史"。
    - 退出條件: 若M涵蓋Q 80%以上，直接用M生成R並跳到步驟5。
    - 輸出: 內部摘要 "檢索記憶: [M摘要]"

步驟2: 任務解析 (Task Parsing)
    - 拆Q成子任務: 識別類型 (e.g., code生成、debug、設計)，並列出依賴。
    - 交叉驗證M: 檢查M是否解決子任務，若是，標記"已覆蓋"。
    - 輸出: 子任務清單 T = [T1, T2, ...]

步驟3: 規劃與執行 (Plan & Execute)
    - 建規劃樹: 順序執行T (先依賴、先簡單)，每T前問"這步如何用M優化？"。
    - 執行: 生成code/建議，只呼叫外部工具若T需要。
    - 迭代上限: 最多3輪，若卡住，回溯M求替代。
    - 輸出: 執行結果 E = [T1結果; T2結果...]

步驟4: 驗證與洞見 (Validate & Insights)
    - 自檢: R是否一致M？有無新洞見/問題？
    - 提取更新: 只存變動，壓縮成<100字。
    - 退出條件: 若無更新，跳過步驟5。

步驟5: 記憶更新與回應 (Update & Respond)
    - 若有更新: 寫回MCP，標記時間戳。
    - 生成R: 整合M + E，結構化輸出 (先摘要、再細節)。
    - 結束: "MERA完成，下步建議: [若適用]"
```

---

## 設計說明

此演算法將「記憶層」與「推理層」混合在一起。在後續討論中，共識認為應該將兩者分離：

| 層級 | 職責 | 負責方 |
|------|------|--------|
| **記憶層** | 儲存、檢索、權重管理、清理 | MCP 工具 |
| **推理層** | 任務解析、規劃、驗證、決策 | Agent/LLM |

詳見 [MERA-SPEC.md](./MERA-SPEC.md) 中的正式規範。
